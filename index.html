<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0,
               viewport-fit=cover, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#4d8440">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" sizes="180x180" href="./pwa_icon_180.png">
<title>Jump In</title>
<style>
  :root {
    --cell: min(14vw, 72px);
    --gap: 4px;
    --padding: 12px;
    --bg: #6aa85b;
    --hole: #222;
    --fox1: #f48c43;
    --fox2: #d07832;
  }
  
  * {
    box-sizing: border-box;
  }
  
  body {
    margin: 0;
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    font-family: -apple-system, sans-serif;
    padding: 8px;
    gap: 8px;
    height: 100dvh;
    touch-action: none;
    overflow: hidden;
  }
  
  h2 {
    color: white;
    margin: 0;
    font-size: clamp(24px, 6vw, 32px);
  }
  
  #puzzleLabel {
    color: white;
    font-size: clamp(16px, 4vw, 20px);
    margin: 0;
  }
  
  #board {
    display: grid;
    grid-template-columns: repeat(5, var(--cell));
    grid-template-rows: repeat(5, var(--cell));
    gap: var(--gap);
    background: #4d8440;
    padding: var(--padding);
    border-radius: 18px;
    position: relative;
    flex-shrink: 0;
  }
  
  .cell {
    width: var(--cell);
    height: var(--cell);
    background: #7cb46b;
    border-radius: 10px;
    position: relative;
  }
  
  .hole {
    width: 70%;
    height: 70%;
    background: var(--hole);
    border-radius: 50%;
    position: absolute;
    top: 15%;
    left: 15%;
    z-index: 1;
  }
  
  .mushroom {
    font-size: clamp(32px, 8vw, 48px);
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3;
    pointer-events: none;
  }
  
  .rabbit {
    font-size: clamp(32px, 8vw, 48px);
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 4;
    pointer-events: none;
  }
  
  .selected {
    outline: 3px solid white;
    outline-offset: -3px;
    z-index: 20 !important;
  }
  
  .fox {
    position: absolute;
    border-radius: 12px;
    z-index: 12;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(36px, 10vw, 56px);
    user-select: none;
    cursor: grab;
    touch-action: none;
  }
  
  .fox1 { background: var(--fox1); }
  .fox2 { background: var(--fox2); }
  
  .fox.dragging {
    opacity: 0.85;
  }
  
  .button-container {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    width: 100%;
  }
  
  button {
    padding: 8px 16px;
    font-size: clamp(14px, 4vw, 16px);
    border-radius: 8px;
    border: none;
    background: #3b8b3f;
    color: #fff;
    flex: 1;
    min-width: 80px;
    max-width: 120px;
    touch-action: manipulation;
  }
  
  button:active {
    opacity: 0.8;
  }
  
  @media (min-width: 768px) {
    :root {
      --cell: 80px;
    }
    
    body {
      padding: 20px;
      gap: 16px;
    }
  }
  
  @media (orientation: landscape) {
    body {
      padding: 8px;
      gap: 8px;
    }
    
    h2, #puzzleLabel {
      margin: 2px 0;
    }
  }
  
  #qrOverlay{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.6);z-index:999;
  }
  #qrBox{
    background:#fff;padding:16px 20px;border-radius:12px;text-align:center;
    box-shadow:0 0 20px rgba(0,0,0,.4);
  }
  #qrBox canvas{width:180px;height:180px;}
  #qrBox p{margin:8px 0 0;font-size:14px;color:#222;}
</style>
</head>
<body>
<h2 id="title">Kaninkolo</h2>
<div id="puzzleLabel"></div>
<div id="board"></div>
<div class="button-container">
  <button id="prevBtn">Edellinen</button>
  <button id="nextBtn">Seuraava</button>
  <button id="resetBtn">Alkuun</button>
</div>

<div id="qrOverlay">
  <div id="qrBox">
    <canvas id="qr"></canvas>
    <p>ymouse91.github.io/jumpin/</p>
  </div>
</div>

<script>

/* Hae CSS-muuttujat dynaamisesti */
function getGridDimensions() {
  const boardEl = document.getElementById("board");
  const boardWidth = boardEl.offsetWidth;
  const style = getComputedStyle(document.documentElement);
  const gap = parseFloat(style.getPropertyValue('--gap').trim());
  const pad = parseFloat(style.getPropertyValue('--padding').trim());
  
  // (boardWidth - 2*pad - 4*gap) / 5 = cell
  const cell = (boardWidth - 2*pad - 4*gap) / 5;
  
  return { cell, gap, pad };
}

/* JSON NORMALISOINTI */
function normalizePuzzleJSON(data){
  if (Array.isArray(data) && Array.isArray(data[0]) && Array.isArray(data[0][0])) {
    return data.map((g,i)=>({ name:"Pulma "+(i+1), grid:g }));
  }
  if (Array.isArray(data) && typeof data[0]==="object" && data[0].grid) {
    return data;
  }
  throw new Error("JSON ei kelpaa");
}

/* STATE */
let PUZZLES = [];
let currentIndex = 0;
let puzzle;
let board;

let selectedRabbit = null;
let selectedFox    = null;

let dragFox = null;
let dragEl  = null;

/* LATAA PULMAT */
async function loadPuzzleFile(){
  const res = await fetch("jumpin_puzzles.json");
  const raw = await res.json();
  PUZZLES = normalizePuzzleJSON(raw);

  currentIndex = 0;
  loadCurrentPuzzle();
}

/* Lataa yksi pulma */
function loadCurrentPuzzle(){
  const p = PUZZLES[currentIndex];
  puzzle = p.grid.map(row => row.join(""));
  updatePuzzleLabel();
  resetBoard();
}

/* Pulma X / N â€“ Nimi */
function updatePuzzleLabel(){
  let t = `Pulma ${currentIndex+1} / ${PUZZLES.length}`;
  if (PUZZLES[currentIndex].name) t += " â€“ " + PUZZLES[currentIndex].name;
  document.getElementById("puzzleLabel").textContent = t;
}

/* PARSE */
function parsePuzzle(lines){
  const raw = lines.map(r=>r.split(""));
  const out = [...Array(5)].map(()=>Array(5).fill(null));
  const used={};

  for (let y=0;y<5;y++){
    for (let x=0;x<5;x++){
      const c=raw[y][x];
      if (c==="o") continue;
      if (c==="h") { out[y][x]={type:"hole"}; continue; }
      if (c==="m") { out[y][x]={type:"mushroom"}; continue; }
      if (c==="p") { out[y][x]={type:"rabbit_hole"}; continue; }
      if (c==="r") { out[y][x]={type:"rabbit"}; continue; }

      if (c==="k" || c==="f"){
        if (used[x+","+y]) continue;
        const id = (c==="f") ? "fox1" : "fox2";

        if (x+1<5 && raw[y][x+1]===c){
          out[y][x]={type:"fox",dir:"h",id};
          out[y][x+1]={type:"fox",dir:"h",id};
          used[x+","+y]=used[(x+1)+","+y]=true;
        }
        else if (y+1<5 && raw[y+1][x]===c){
          out[y][x]={type:"fox",dir:"v",id};
          out[y+1][x]={type:"fox",dir:"v",id};
          used[x+","+y]=used[x+","+(y+1)]=true;
        }
      }
    }
  }
  return out;
}

/* RESET */
function resetBoard(){
  board = parsePuzzle(puzzle);
  render();
}

/* RENDER */
function render(){
  const el=document.getElementById("board");
  el.innerHTML="";
  const foxGroups={};

  for (let y=0;y<5;y++){
    for (let x=0;x<5;x++){
      const cell=document.createElement("div");
      cell.className="cell";

      const orig=puzzle[y][x];
      const obj =board[y][x];

      if (orig==="h" || orig==="p"){
        let h=document.createElement("div");
        h.className="hole";
        cell.appendChild(h);
      }

      if (obj){
        if (obj.type==="mushroom"){
          let m=document.createElement("div");
          m.className="mushroom";
          m.textContent="ðŸ„";
          cell.appendChild(m);
        }

        if (obj.type==="rabbit" || obj.type==="rabbit_hole"){
          let r=document.createElement("div");
          r.className="rabbit";
          r.textContent="ðŸ°";
          if (selectedRabbit &&
              selectedRabbit.x===x && selectedRabbit.y===y){
            r.classList.add("selected");
          }
          cell.appendChild(r);
        }

        if (obj.type==="fox"){
          if (!foxGroups[obj.id]) foxGroups[obj.id]=[];
          foxGroups[obj.id].push({x,y,dir:obj.dir,id:obj.id});
        }
      }

      cell.onclick=()=>clickCell(x,y);
      el.appendChild(cell);
    }
  }

  /* FOX visual blocks */
  for (let id in foxGroups){
    const p = foxGroups[id];
    const xs=p.map(v=>v.x),
          ys=p.map(v=>v.y);
    const minX=Math.min(...xs),
          minY=Math.min(...ys);
    const dir=p[0].dir;

    const fx=document.createElement("div");
    fx.className="fox "+id;
    fx.textContent="ðŸ¦Š";

    if (selectedFox === id){
      fx.classList.add("selected");
    }

    const { cell, gap, pad } = getGridDimensions();
    const boardRect = el.getBoundingClientRect();
    fx.style.left = (pad + minX*(cell+gap))+"px";
    fx.style.top  = (pad + minY*(cell+gap))+"px";

    if (dir==="h"){
      fx.style.width = (cell*2 + gap)+"px";
      fx.style.height = cell+"px";
    } else {
      fx.style.width = cell+"px";
      fx.style.height = (cell*2 + gap)+"px";
    }

    fx.onpointerdown = (e)=>foxPointerDown(e,id,minX,minY,dir);
    el.appendChild(fx);
  }
}

/* FOX DRAG */
function foxPointerDown(e,id,minX,minY,dir){
  selectedRabbit = null;
  selectedFox    = id;

  dragFox = {id,minX,minY,dir};
  dragEl  = e.target;

  dragEl.classList.add("dragging");

  dragFox.startLeft = parseFloat(dragEl.style.left);
  dragFox.startTop  = parseFloat(dragEl.style.top);
  dragFox.pointerStartX = e.clientX;
  dragFox.pointerStartY = e.clientY;

  document.body.onpointermove = foxPointerMove;
  document.body.onpointerup   = foxPointerUp;
}

function foxPointerMove(e){
  if (!dragFox) return;
  const dx=e.clientX-dragFox.pointerStartX;
  const dy=e.clientY-dragFox.pointerStartY;

  if (dragFox.dir==="h"){
    dragEl.style.left = dragFox.startLeft + dx + "px";
  } else {
    dragEl.style.top  = dragFox.startTop  + dy + "px";
  }
}

/* POINTER-UP */
function foxPointerUp(e){
  if (!dragFox) return;

  dragEl.classList.remove("dragging");

  const dx=e.clientX-dragFox.pointerStartX;
  const dy=e.clientY-dragFox.pointerStartY;
  const { cell } = getGridDimensions();

  let steps = dragFox.dir==="h"
    ? Math.round(dx/cell)
    : Math.round(dy/cell);

  moveFoxSteps(dragFox,steps);

  dragFox=null;
  dragEl=null;

  document.body.onpointermove=null;
  document.body.onpointerup=null;

  setTimeout(render, 0);
}

/* MOVE FOX */
function moveFoxSteps(f,steps){
  if (steps===0) return;
  const abs=Math.abs(steps);

  for(let i=0;i<abs;i++){
    const forward=(steps>0);
    if(!moveFoxOne(f.id,f.dir,forward)) break;
  }
}

function moveFoxOne(id,dir,forward){
  let parts=[];
  for(let y=0;y<5;y++){
    for(let x=0;x<5;x++){
      if(board[y][x] && board[y][x].type==="fox" && board[y][x].id===id){
        parts.push({x,y});
      }
    }
  }

  const xs=parts.map(p=>p.x),
        ys=parts.map(p=>p.y);
  const minX=Math.min(...xs),
        maxX=Math.max(...xs);
  const minY=Math.min(...ys),
        maxY=Math.max(...ys);

  if(dir==="h"){
    if(forward){
      if(maxX+1>4 || board[minY][maxX+1]) return false;
      board[minY][maxX+1]={type:"fox",dir:"h",id};
      board[minY][maxX]  ={type:"fox",dir:"h",id};
      board[minY][minX]  =null;
    } else {
      if(minX-1<0 || board[minY][minX-1]) return false;
      board[minY][minX-1]={type:"fox",dir:"h",id};
      board[minY][minX]  ={type:"fox",dir:"h",id};
      board[minY][maxX]  =null;
    }
  } else {
    if(forward){
      if(maxY+1>4 || board[maxY+1][minX]) return false;
      board[maxY+1][minX]={type:"fox",dir:"v",id};
      board[maxY]  [minX]={type:"fox",dir:"v",id};
      board[minY]  [minX]=null;
    } else {
      if(minY-1<0 || board[minY-1][minX]) return false;
      board[minY-1][minX]={type:"fox",dir:"v",id};
      board[minY]  [minX]={type:"fox",dir:"v",id};
      board[maxY]  [minX]=null;
    }
  }
  return true;
}

/* CLICK RABBIT + MOVE */
function clickCell(x,y){
  selectedFox=null;

  const o=board[y][x];
  if(o && (o.type==="rabbit"||o.type==="rabbit_hole")){
    selectedRabbit={x,y};
    render();
    return;
  }

  if(selectedRabbit){
    rabbitMove(selectedRabbit.x,selectedRabbit.y,x,y);
    selectedRabbit=null;
    render();
    checkWin();
  }
}

function rabbitMove(sx,sy,tx,ty){
  if(sx!==tx && sy!==ty)return;

  const dx=Math.sign(tx-sx),
        dy=Math.sign(ty-sy);

  if(Math.abs(tx-sx)+Math.abs(ty-sy)===1)return;

  let cx=sx+dx, cy=sy+dy, jumped=false;

  while(true){
    if(cx<0||cx>4||cy<0||cy>4)return;

    if(cx===tx && cy===ty){
      if(!jumped)return;
      board[sy][sx]=null;

      if(puzzle[ty][tx]==="h" || puzzle[ty][tx]==="p")
        board[ty][tx]={type:"rabbit_hole"};
      else
        board[ty][tx]={type:"rabbit"};

      return;
    }

    if(!board[cy][cx])return;
    jumped=true;
    cx+=dx; cy+=dy;
  }
}

/* WIN */
function checkWin(){
  let total=0, inHole=0;
  for(let y=0;y<5;y++){
    for(let x=0;x<5;x++){
      const o=board[y][x];
      if(o && (o.type==="rabbit"||o.type==="rabbit_hole")){
        total++;
        if(o.type==="rabbit_hole") inHole++;
      }
    }
  }
  if(total>0 && total===inHole)
    setTimeout(()=>alert("ðŸŽ‰ Pulma ratkaistu!"),100);
}

/* NAPIT */
document.getElementById("prevBtn").onclick=function(){
  if(currentIndex>0){
    currentIndex--;
    loadCurrentPuzzle();
  }
};

document.getElementById("nextBtn").onclick=function(){
  if(currentIndex<PUZZLES.length-1){
    currentIndex++;
    loadCurrentPuzzle();
  }
};

document.getElementById("resetBtn").onclick=resetBoard;

/* SERVICE WORKER */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('./service-worker.js')
      .catch(err => console.warn('Service workerin rekisterÃ¶inti epÃ¤onnistui:', err));
  });
}

/* QR KOODI */
const title = document.getElementById("title");
const overlay = document.getElementById("qrOverlay");
title.addEventListener('click', ()=>overlay.style.display='flex');
overlay.addEventListener('click', ()=>overlay.style.display='none');

/* INIT */
loadPuzzleFile();

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
<script>
const qr = new QRious({
  element: document.getElementById('qr'),
  value: 'https://ymouse91.github.io/jumpin/',
  size: 180
});
</script>

</body>
</html>